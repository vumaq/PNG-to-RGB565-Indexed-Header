<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RGB565 Indexed Image Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/rgbquant@1.1.2/src/rgbquant.min.js"></script>
    <style>
        .checkerboard {
            background-image: linear-gradient(45deg, #1e293b 25%, transparent 25%), linear-gradient(-45deg, #1e293b 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #1e293b 75%), linear-gradient(-45deg, transparent 75%, #1e293b 75%);
            background-size: 40px 40px;
            background-position: 0 0, 0 20px, 20px -20px, -20px 0px;
            background-color: #0f172a;
        }
        canvas { max-width: 90vw; max-height: 100%; object-fit: contain; }
        #drop-icon { transition: transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        body.drag-active #drop-icon { transform: scale(2.5); color: #818cf8; }
        .loading-pulse { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } }
    </style>
</head>
<body id="global-drop" class="checkerboard h-screen w-screen flex flex-col text-slate-200 overflow-hidden m-0">

    <div id="toast" class="fixed top-4 right-4 z-50 hidden">
        <div class="bg-slate-900 border border-slate-700 px-4 py-2 rounded-xl shadow-2xl flex items-center gap-3">
            <div id="status-dot" class="w-2 h-2 rounded-full bg-indigo-500"></div>
            <span id="status-text" class="text-[10px] font-bold uppercase tracking-widest text-slate-300">Ready</span>
        </div>
    </div>

    <header class="w-full px-8 pt-4 flex flex-col gap-1 pointer-events-none z-10">
        <h1 class="text-3xl font-black text-white tracking-tighter uppercase leading-none">RGB565 Indexed Converter</h1>
    </header>

    <main class="flex-1 w-full py-4 flex items-center justify-center relative overflow-hidden pointer-events-none">
        <input type="file" id="file-input" accept="image/*" class="hidden">
        <div id="drop-content" class="text-center">
            <svg id="drop-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-16 h-16 text-slate-700 mb-4 mx-auto">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v6m3-3H9m12 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
            </svg>
            <p class="text-slate-600 font-bold uppercase tracking-[0.2em] text-[10px]">Drop Image Anywhere</p>
        </div>
        <canvas id="preview-canvas" class="hidden shadow-2xl border border-slate-700/50 bg-black z-20"></canvas>
    </main>

    <div id="summary-bar" class="hidden h-14 bg-slate-900/95 border-t border-slate-800 px-8 z-30 backdrop-blur-sm">
        <div class="h-full w-full flex items-center gap-10 text-[10px] font-bold uppercase tracking-widest">
            <div class="flex flex-col"><span class="text-slate-500 mb-0.5">File</span><span id="info-filename" class="text-slate-200">-</span></div>
            <div class="flex flex-col"><span class="text-slate-500 mb-0.5">Resolution</span><span id="info-res" class="text-slate-200">-</span></div>
            <div class="flex flex-col"><span class="text-slate-500 mb-0.5">Source Colors</span><span id="info-source-colors" class="text-slate-200">-</span></div>
            <div class="flex flex-col"><span class="text-slate-500 mb-0.5">Transparency</span><span id="info-alpha" class="text-slate-200">No</span></div>
        </div>
    </div>

    <nav id="action-bar" class="hidden h-28 bg-slate-950 border-t border-slate-800 px-8 z-30">
        <div class="h-full w-full grid grid-cols-4 gap-4 items-center">
            <div class="flex flex-col justify-center bg-slate-900 px-6 h-16 rounded-xl border border-slate-700">
                <label class="text-[9px] font-black text-slate-500 uppercase tracking-widest mb-1">Max Palette</label>
                <input type="number" id="pal-limit" value="256" min="2" max="256" 
                    class="bg-transparent text-indigo-400 font-bold text-lg focus:outline-none">
            </div>
            <div class="flex items-center gap-4 bg-slate-900 px-6 h-16 rounded-xl border border-slate-700">
                <div class="flex flex-col flex-1">
                    <label class="text-[9px] font-black text-slate-500 uppercase tracking-widest mb-1">Alpha Key</label>
                    <span id="alpha-status-text" class="text-[10px] font-bold text-slate-500 uppercase">None</span>
                </div>
                <div id="alpha-preview" class="w-8 h-8 rounded-lg border border-white/10 bg-[#FF00FF] opacity-20"></div>
            </div>
            <button id="toggle-view" class="h-16 rounded-xl bg-slate-900 border border-slate-700 text-slate-300 flex flex-col items-center justify-center hover:bg-slate-800 transition-colors">
                <span class="text-[9px] font-black uppercase tracking-[0.2em] text-slate-500 mb-1">View Mode</span>
                <span id="view-mode-label" class="text-[10px] font-bold uppercase">Processed</span>
            </button>
            <button id="download-btn" class="h-16 rounded-xl bg-indigo-600 text-white font-black shadow-lg shadow-indigo-900/20 flex flex-col items-center justify-center hover:bg-indigo-500 active:scale-[0.98] transition-all">
                <span class="text-[9px] font-black uppercase tracking-[0.2em] text-indigo-200 mb-1">Export</span>
                <span class="text-[10px] font-bold uppercase">Download .h</span>
            </button>
        </div>
    </nav>

    <script id="worker-script" type="text/javascript-worker">
        importScripts('https://cdn.jsdelivr.net/npm/rgbquant@1.1.2/src/rgbquant.min.js');
        
        self.onmessage = function(e) {
            const { imgData, maxColors, hasAlpha, downloadName } = e.data;
            
            // Quantize to requested limit (minus 1 if alpha is reserved)
            const qColors = hasAlpha ? Math.min(maxColors - 1, 255) : maxColors;
            const q = new RgbQuant({ colors: qColors, method: 2, initColors: 4096 });
            
            q.sample(imgData);
            let rawPalette = q.palette(); // Uint8Array
            let indices = q.reduce(imgData); 
            
            // Calculate final palette size
            const imageColorCount = rawPalette.length / 4;
            const finalCount = hasAlpha ? imageColorCount + 1 : imageColorCount;
            const finalPalette = new Uint8Array(finalCount * 4);
            
            if(hasAlpha) {
                // Index 0: Transparency Mask (Pink)
                finalPalette[0] = 255; finalPalette[1] = 0; finalPalette[2] = 255; finalPalette[3] = 255;
                // Append the rest of the colors
                finalPalette.set(rawPalette, 4);

                // Remap: shift indices by 1, map alpha pixels to 0
                for (let i = 0; i < indices.length; i++) {
                    if (imgData.data[i*4 + 3] < 128) {
                        indices[i] = 0;
                    } else {
                        indices[i] = indices[i] + 1;
                    }
                }
            } else {
                finalPalette.set(rawPalette);
            }

            // Generate Header with dynamic array sizes
            let parts = [
                `/* Generated by RGB565 Indexed Converter */\n#ifndef BITMAP_DATA_H\n#define BITMAP_DATA_H\n#include <stdint.h>\n\n`,
                `static constexpr uint16_t GFX_W = ${imgData.width};\nstatic constexpr uint16_t GFX_H = ${imgData.height};\n\n`,
                `const uint8_t epd_bitmap_${downloadName}[] PROGMEM = {\n    `
            ];
            
            let idxs = [];
            for (let i = 0; i < indices.length; i++) {
                idxs.push(indices[i]);
                if ((i + 1) % 16 === 0 && i !== indices.length - 1) idxs.push("\n    ");
            }
            parts.push(idxs.join(", "));
            parts.push(`\n};\n\nconst uint16_t epd_palette_${downloadName}[${finalCount}] PROGMEM = {\n    `);
            
            let pals = [];
            for (let i = 0; i < finalCount; i++) {
                const r = finalPalette[i*4], g = finalPalette[i*4+1], b = finalPalette[i*4+2];
                const rgb565 = (hasAlpha && i === 0) ? 0xF81F : ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);
                pals.push("0x" + rgb565.toString(16).toUpperCase().padStart(4, '0'));
                if ((i + 1) % 8 === 0 && i !== finalCount - 1) pals.push("\n    ");
            }
            parts.push(pals.join(", "));
            parts.push(`\n};\n#endif`);
            
            self.postMessage({ 
                palette: finalPalette, 
                indices: indices, 
                finalHeader: parts.join(""), 
                hasAlpha: hasAlpha 
            });
        };
    </script>

    <script>
        const body = document.getElementById('global-drop');
        const fileInput = document.getElementById('file-input');
        const previewCanvas = document.getElementById('preview-canvas');
        const summaryBar = document.getElementById('summary-bar');
        const actionBar = document.getElementById('action-bar');
        const toast = document.getElementById('toast');
        const statusText = document.getElementById('status-text');
        const statusDot = document.getElementById('status-dot');
        const palLimitInput = document.getElementById('pal-limit');
        const dropContent = document.getElementById('drop-content');

        let originalImg = null, processedData = null, isViewOriginal = false, finalHeader = "", downloadName = "image", currentHasAlpha = false;
        const worker = new Worker(URL.createObjectURL(new Blob([document.getElementById('worker-script').textContent], { type: 'text/javascript' })));

        function updateStatus(msg, isLoading = false) {
            toast.classList.remove('hidden');
            statusText.innerText = msg;
            statusDot.className = isLoading ? "w-2 h-2 rounded-full bg-indigo-500 loading-pulse" : "w-2 h-2 rounded-full bg-green-500";
            if (!isLoading) setTimeout(() => toast.classList.add('hidden'), 2000);
        }

        worker.onmessage = (e) => {
            const { palette, indices, finalHeader: header, hasAlpha } = e.data;
            processedData = { palette, indices, w: previewCanvas.width, h: previewCanvas.height };
            finalHeader = header;
            currentHasAlpha = hasAlpha;
            updateStatus("Ready");
            [summaryBar, actionBar, previewCanvas].forEach(el => el.classList.remove('hidden'));
            dropContent.classList.add('hidden');
            renderView();
        };

        body.onclick = (e) => { if(!e.target.closest('nav, #summary-bar, header')) fileInput.click(); };
        fileInput.onchange = (e) => handleFile(e.target.files[0]);

        window.addEventListener('dragover', (e) => { e.preventDefault(); body.classList.add('drag-active'); });
        window.addEventListener('dragleave', (e) => { if (!e.relatedTarget) body.classList.remove('drag-active'); });
        window.addEventListener('drop', (e) => { e.preventDefault(); body.classList.remove('drag-active'); handleFile(e.dataTransfer.files[0]); });

        palLimitInput.onchange = () => { if(originalImg) processImage(originalImg); };
        document.getElementById('toggle-view').onclick = () => { 
            isViewOriginal = !isViewOriginal; 
            document.getElementById('view-mode-label').innerText = isViewOriginal ? "Original" : "Processed";
            renderView(); 
        };

        function handleFile(file) {
            if (!file?.type.startsWith('image/')) return;
            downloadName = file.name.split('.')[0].replace(/[^a-z0-9]/gi, '_');
            document.getElementById('info-filename').innerText = file.name;
            const img = new Image();
            img.onload = () => { originalImg = img; processImage(img); };
            img.src = URL.createObjectURL(file);
        }

        function processImage(img) {
            updateStatus("Quantizing...", true);
            const w = img.width, h = img.height;
            document.getElementById('info-res').innerText = `${w}x${h}`;
            previewCanvas.width = w; previewCanvas.height = h;
            const ctx = previewCanvas.getContext('2d');
            ctx.clearRect(0, 0, w, h);
            ctx.drawImage(img, 0, 0);
            const imageDataObj = ctx.getImageData(0, 0, w, h);
            
            let hasAlpha = false;
            for (let i = 0; i < imageDataObj.data.length; i += 4) {
                if(imageDataObj.data[i+3] < 128) { hasAlpha = true; break; }
            }
            
            document.getElementById('info-alpha').innerText = hasAlpha ? "Yes" : "No";
            document.getElementById('alpha-preview').style.opacity = hasAlpha ? "1" : "0.2";
            document.getElementById('alpha-status-text').innerText = hasAlpha ? "Index 0" : "None";
            document.getElementById('alpha-status-text').className = hasAlpha ? "text-[10px] font-bold text-pink-500 uppercase" : "text-[10px] font-bold text-slate-500 uppercase";

            worker.postMessage({ imgData: imageDataObj, maxColors: parseInt(palLimitInput.value), hasAlpha, downloadName });
        }

        function renderView() {
            if (!processedData) return;
            const ctx = previewCanvas.getContext('2d');
            ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            if (isViewOriginal) { 
                ctx.drawImage(originalImg, 0, 0); 
                return;
            }

            const imgData = ctx.createImageData(processedData.w, processedData.h);
            const pal = processedData.palette;
            const idxs = processedData.indices;

            for(let i=0; i < idxs.length; i++) {
                const paletteIdx = idxs[i];
                const pixelOffset = i * 4;
                const colorOffset = paletteIdx * 4;

                imgData.data[pixelOffset]     = pal[colorOffset];
                imgData.data[pixelOffset + 1] = pal[colorOffset + 1];
                imgData.data[pixelOffset + 2] = pal[colorOffset + 2];
                imgData.data[pixelOffset + 3] = 255; 
            }
            ctx.putImageData(imgData, 0, 0);
            document.getElementById('info-source-colors').innerText = (pal.length/4).toString();
        }

        document.getElementById('download-btn').onclick = () => {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([finalHeader], { type: 'text/plain' }));
            a.download = `${downloadName}.h`;
            a.click();
            updateStatus("Header Downloaded");
        };
    </script>
</body>
</html>