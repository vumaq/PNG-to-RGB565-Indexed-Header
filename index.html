<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8-Bit Indexed RGB565 Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/rgbquant@1.1.2/src/rgbquant.min.js"></script>
    <style>
        .checkerboard {
            background-image: linear-gradient(45deg, #1e293b 25%, transparent 25%), linear-gradient(-45deg, #1e293b 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #1e293b 75%), linear-gradient(-45deg, transparent 75%, #1e293b 75%);
            background-size: 40px 40px;
            background-position: 0 0, 0 20px, 20px -20px, -20px 0px;
            background-color: #0f172a;
        }
        canvas { max-width: 90vw; max-height: 100%; object-fit: contain; image-rendering: pixelated; }
        #drop-icon { transition: transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        body.drag-active #drop-icon { transform: scale(2.5); color: #818cf8; }
        .loading-pulse { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } }
    </style>
</head>
<body id="global-drop" class="checkerboard h-screen w-screen flex flex-col text-slate-200 overflow-hidden m-0">

    <div id="toast" class="fixed top-4 right-4 z-50 hidden">
        <div class="bg-slate-900 border border-slate-700 px-4 py-2 rounded-xl shadow-2xl flex items-center gap-3">
            <div id="status-dot" class="w-2 h-2 rounded-full bg-indigo-500"></div>
            <span id="status-text" class="text-[10px] font-bold uppercase tracking-widest text-slate-300">Ready</span>
        </div>
    </div>

    <header class="w-full px-8 pt-4 flex flex-col gap-1 pointer-events-none z-10">
        <h1 class="text-3xl font-black text-white tracking-tighter uppercase leading-none">8-Bit Indexed</h1>
    </header>

    <main class="flex-1 w-full py-4 flex items-center justify-center relative overflow-hidden pointer-events-none">
        <input type="file" id="file-input" accept="image/*" class="hidden">
        <div id="drop-content" class="text-center">
            <svg id="drop-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-16 h-16 text-slate-700 mb-4 mx-auto">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v6m3-3H9m12 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
            </svg>
            <p class="text-slate-600 font-bold uppercase tracking-[0.2em] text-[10px]">Drop Image Anywhere</p>
        </div>
        <canvas id="preview-canvas" class="hidden shadow-2xl border border-slate-700/50 z-20"></canvas>
    </main>

    <div id="summary-bar" class="hidden h-14 bg-slate-900/95 border-t border-slate-800 px-8 z-30 backdrop-blur-sm">
        <div class="h-full w-full flex items-center gap-10 text-[10px] font-bold uppercase tracking-widest">
            <div class="flex flex-col"><span class="text-slate-500 mb-0.5">File</span><span id="info-filename" class="text-slate-200">-</span></div>
            <div class="flex flex-col"><span class="text-slate-500 mb-0.5">Resolution</span><span id="info-res" class="text-slate-200">-</span></div>
            <div class="flex flex-col"><span class="text-slate-500 mb-0.5">Colors Found</span><span id="info-source-colors" class="text-slate-200">-</span></div>
        </div>
    </div>

    <nav id="action-bar" class="hidden h-28 bg-slate-950 border-t border-slate-800 px-8 z-30">
        <div class="h-full w-full grid grid-cols-4 gap-4 items-center">
            <div class="flex flex-col justify-center bg-slate-900 px-6 h-16 rounded-xl border border-slate-700">
                <label class="text-[9px] font-black text-slate-500 uppercase tracking-widest mb-1">Max Palette Size</label>
                <input type="number" id="pal-limit" value="64" min="2" max="256" 
                    class="bg-transparent text-indigo-400 font-bold text-lg focus:outline-none">
            </div>

            <div class="flex flex-col justify-center bg-slate-900 px-6 h-16 rounded-xl border border-slate-700">
                <label class="text-[9px] font-black text-slate-500 uppercase tracking-widest mb-1">Transparency Key</label>
                <input type="text" id="alpha-value-input" value="0xF81F" 
                    class="bg-transparent text-pink-500 font-bold text-lg focus:outline-none uppercase" placeholder="0x0000">
            </div>

            <button id="toggle-view" class="h-16 rounded-xl bg-slate-900 border border-slate-700 text-slate-300 flex flex-col items-center justify-center hover:bg-slate-800 transition-colors">
                <span class="text-[9px] font-black uppercase tracking-[0.2em] text-slate-500 mb-1">View Mode</span>
                <span id="view-mode-label" class="text-[10px] font-bold uppercase">Processed</span>
            </button>

            <button id="download-btn" class="h-16 rounded-xl bg-indigo-600 text-white font-black shadow-lg shadow-indigo-900/20 flex flex-col items-center justify-center hover:bg-indigo-500 active:scale-[0.98] transition-all">
                <span class="text-[9px] font-black uppercase tracking-[0.2em] text-indigo-200 mb-1">Export</span>
                <span class="text-[10px] font-bold uppercase">Download .h</span>
            </button>
        </div>
    </nav>

    <script id="worker-script" type="text/javascript-worker">
        importScripts('https://cdn.jsdelivr.net/npm/rgbquant@1.1.2/src/rgbquant.min.js');
        
        self.onmessage = function(e) {
            const { imgData, maxColors, downloadName, rawAlphaValue } = e.data;
            const limit = parseInt(maxColors);
            
            const val = parseInt(rawAlphaValue, 16);
            const rK = Math.round(((val >> 11) & 0x1F) * (255 / 31));
            const gK = Math.round(((val >> 5) & 0x3F) * (255 / 63));
            const bK = Math.round((val & 0x1F) * (255 / 31));

            // Determine if transparency exists
            let hasTransparency = false;
            for (let i = 3; i < imgData.data.length; i += 4) {
                if (imgData.data[i] < 128) {
                    hasTransparency = true;
                    break;
                }
            }

            // If no transparency, use the full limit for RgbQuant
            const qColors = hasTransparency ? Math.max(1, limit - 1) : limit;
            const q = new RgbQuant({ colors: qColors, method: 2, sample: 1 });
            q.sample(imgData);
            
            const rawPalette = q.palette(); 
            const rawIndices = q.reduce(imgData, 2); 
            
            let finalPalette = [];
            let finalIndices = new Uint8Array(rawIndices.length);

            if (hasTransparency) {
                // Reserve Index 0 for your chosen key color
                finalPalette.push(rK, gK, bK, 255); 
                for (let i = 0; i < rawPalette.length; i++) finalPalette.push(rawPalette[i]);
                for (let i = 0; i < rawIndices.length; i++) {
                    finalIndices[i] = (imgData.data[i * 4 + 3] < 128) ? 0 : rawIndices[i] + 1;
                }
            } else {
                // Normal mode: Use exactly what RgbQuant returned
                finalPalette = rawPalette;
                finalIndices = rawIndices;
            }

            const count = finalPalette.length / 4;

            let header = `/* Generated 8-Bit Indexed Data */\n#ifndef BITMAP_DATA_H\n#define BITMAP_DATA_H\n#include <stdint.h>\n\n`;
            header += `static constexpr uint16_t GFX_W = ${imgData.width};\n`;
            header += `static constexpr uint16_t GFX_H = ${imgData.height};\n\n`;
            
            header += `const uint8_t epd_bitmap_${downloadName}[] PROGMEM = {\n    `;
            for (let i = 0; i < finalIndices.length; i++) {
                header += finalIndices[i];
                if (i < finalIndices.length - 1) {
                    header += (i + 1) % 16 === 0 ? ",\n    " : ", ";
                }
            }
            header += `\n};\n\n`;

            header += `const uint16_t epd_palette_${downloadName}[${count}] PROGMEM = {\n    `;
            for (let i = 0; i < count; i++) {
                if (hasTransparency && i === 0) {
                    header += rawAlphaValue; 
                } else {
                    const r = finalPalette[i*4], g = finalPalette[i*4+1], b = finalPalette[i*4+2];
                    const rgb565 = ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
                    header += "0x" + rgb565.toString(16).toUpperCase().padStart(4, '0');
                }
                
                if (i < count - 1) {
                    header += (i + 1) % 8 === 0 ? ",\n    " : ", ";
                }
            }
            header += `\n};\n#endif`;
            
            self.postMessage({ palette: finalPalette, indices: finalIndices, finalHeader: header });
        };
    </script>

    <script>
        const fileInput = document.getElementById('file-input');
        const previewCanvas = document.getElementById('preview-canvas');
        const palLimitInput = document.getElementById('pal-limit');
        const alphaInput = document.getElementById('alpha-value-input');
        const viewModeLabel = document.getElementById('view-mode-label');

        let originalImg = null, processedData = null, isViewOriginal = false, finalHeader = "", downloadName = "image";
        const worker = new Worker(URL.createObjectURL(new Blob([document.getElementById('worker-script').textContent], { type: 'text/javascript' })));

        function updateStatus(msg, isLoading = false) {
            const toast = document.getElementById('toast');
            toast.classList.remove('hidden');
            document.getElementById('status-text').innerText = msg;
            document.getElementById('status-dot').className = isLoading ? "w-2 h-2 rounded-full bg-indigo-500 loading-pulse" : "w-2 h-2 rounded-full bg-green-500";
            if (!isLoading) setTimeout(() => toast.classList.add('hidden'), 2000);
        }

        worker.onmessage = (e) => {
            processedData = e.data;
            finalHeader = e.data.finalHeader;
            updateStatus("Ready");
            ['summary-bar', 'action-bar', 'preview-canvas'].forEach(id => document.getElementById(id).classList.remove('hidden'));
            document.getElementById('drop-content').classList.add('hidden');
            renderView();
        };

        document.getElementById('global-drop').onclick = (e) => { 
            if(!e.target.closest('nav, #summary-bar, header, canvas')) fileInput.click(); 
        };

        fileInput.onchange = (e) => handleFile(e.target.files[0]);

        window.addEventListener('dragover', (e) => { e.preventDefault(); document.body.classList.add('drag-active'); });
        window.addEventListener('dragleave', (e) => { if (!e.relatedTarget) document.body.classList.remove('drag-active'); });
        window.addEventListener('drop', (e) => { e.preventDefault(); document.body.classList.remove('drag-active'); handleFile(e.dataTransfer.files[0]); });

        palLimitInput.onchange = () => { if(originalImg) processImage(originalImg); };
        alphaInput.onchange = () => { if(originalImg) processImage(originalImg); };

        function handleFile(file) {
            if (!file?.type.startsWith('image/')) return;
            downloadName = file.name.split('.')[0].replace(/[^a-z0-9]/gi, '_');
            document.getElementById('info-filename').innerText = file.name;
            const img = new Image();
            img.onload = () => { originalImg = img; processImage(img); };
            img.src = URL.createObjectURL(file);
        }

        function processImage(img) {
            updateStatus("Processing...", true);
            const w = img.width, h = img.height;
            document.getElementById('info-res').innerText = `${w}x${h}`;
            previewCanvas.width = w; previewCanvas.height = h;
            const ctx = previewCanvas.getContext('2d');
            ctx.clearRect(0, 0, w, h);
            ctx.drawImage(img, 0, 0);
            const imageDataObj = ctx.getImageData(0, 0, w, h);
            
            const colors = new Set();
            for (let i = 0; i < imageDataObj.data.length; i += 4) {
                colors.add((imageDataObj.data[i] << 16) | (imageDataObj.data[i+1] << 8) | imageDataObj.data[i+2]);
            }
            document.getElementById('info-source-colors').innerText = colors.size.toLocaleString();
            worker.postMessage({ 
                imgData: imageDataObj, 
                maxColors: palLimitInput.value, 
                downloadName,
                rawAlphaValue: alphaInput.value 
            });
        }

        function renderView() {
            if (!processedData) return;
            const ctx = previewCanvas.getContext('2d');
            ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            if (isViewOriginal) { 
                ctx.drawImage(originalImg, 0, 0); 
            } else {
                const imgData = ctx.createImageData(previewCanvas.width, previewCanvas.height);
                for(let i=0; i < processedData.indices.length; i++) {
                    const colorOffset = processedData.indices[i] * 4;
                    imgData.data[i*4] = processedData.palette[colorOffset];
                    imgData.data[i*4+1] = processedData.palette[colorOffset+1];
                    imgData.data[i*4+2] = processedData.palette[colorOffset+2];
                    imgData.data[i*4+3] = 255;
                }
                ctx.putImageData(imgData, 0, 0);
            }
        }

        document.getElementById('toggle-view').onclick = () => { 
            isViewOriginal = !isViewOriginal; 
            viewModeLabel.innerText = isViewOriginal ? "Original" : "Processed";
            renderView(); 
        };

        document.getElementById('download-btn').onclick = () => {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([finalHeader], { type: 'text/plain' }));
            a.download = `${downloadName}.h`;
            a.click();
            updateStatus("Exported .h");
        };
    </script>
</body>
</html>